# Java SE

## Java程序基础

### Java语言概述

* “一次编写，到处运行”的原理
  * 编译型语言和解释型语言，Java将代码编译成一种“字节码”，不同平台的虚拟机负责加载字节码并执行
* Java SE/ Java EE/ Java ME
* JDK/ JRE/ JVM

### Java程序的基本结构

* 面向对象的语言

  | 类(class) | 方法(method) |
  | --------- | ------------ |
  | Hello     | main         |
  | NoteBook  | goodMorning  |

  

* 命名规范（标识符）

* 注释

### 数据类型

* 基本数据类型（4类8种）
* 变量
  * 变量的作用范围
* 常量（final）

### 运算

#### 整数运算

##### 运算符

* 算数运算符
* 赋值运算符
* 比较运算符
* 逻辑运算符

##### 四则运算

* 除法：`/`

  整数的数值表示是精确的，整数运算也是精确的，除法也是精确的，因为两个整数相除只能得到结果的整数部分：

  ```java
  int x = 123 / 6;// 20
  ```

  

* 取模（求余数）：`%`

  ```java
  int y = 123 % 6; // 123÷6的余数是3
  ```

  注意：整数的除法对于除数为0时，运行时将报错，但编译不会报错。

* 简写的运算符（复合赋值运算符）`+=`，`-=`，`*=`，`/=`，使用方法如下

  ```java
  n += 100;// n = n + 100;
  n -= 100;// n = n - 100;
  ```

  

##### 溢出

* 注意：整数存在范围限制，如果计算结果超出范围，就会产生溢出，而溢出不会出错，会出现一个奇怪的结果：

  ```java
  // 运算溢出
  public class Main {
      public static void main(String[] args){
          int x = 2147483640;
          int y = 15;
          int sum = x + y;
          System.out.println(sum);// -2147483641
      }
  }
  ```

  要解决上面的问题，可以将`int`换成`long`类型，由于`long`可表示的整型范围更大，结果就不会溢出：

  ```java
  long x = 2147483640;
  long y = 15;
  long sum = x + y;
  System.out.println(sum);//2147483655
  ```

##### 自增/自减

* Java还提供了`++`运算和`--`运算，它们可以对一个整数进行加1或减1的操作：

  ```java
  // 自增/自减运算
  public class Main {
      public static void main(String[] args){
          int n = 333;
          n++;// 334，相当于n = n + 1;
          n--;// 332，相当于n = n - 1;
          int y = 100 + (++n);// 不建议这么写
          System.out.println(y);
      }
  }
  ```

  注意：`++`写在前面和后面的计算结果不同，`++n`表示先加1再引用n，`n++`表示先引用n再加1。不建议把`++`运算混入常规运算中，容易搞混。

##### 移位运算

* 在计算机中，整数总是以二进制的形式表示。可以对整数进行移位运算：

  ```java
  int n = 7;      // 00000000 00000000 00000000 00000111 = 7
  int a = n << 1; // 00000000 00000000 00000000 00001110 = 14
  int b = n << 2; // 00000000 00000000 00000000 00011100 = 28
  int c = n << 28;// 01110000 00000000 00000000 00000000 = 1879048192
  int d = n << 29;// 11100000 00000000 00000000 00000000 = -536870912
  ```

  左移29位时，由于最高位变成`1`，因此结果变成了负数。

* 类似的，对整数7进行右移，结果如下：

  ```java
  int n = 7;      // 00000000 00000000 00000000 00000111 = 7
  int a = n >> 1; // 00000000 00000000 00000000 00000011 = 3
  int b = n >> 2; // 00000000 00000000 00000000 00000001 = 1
  int c = n >> 3; // 00000000 00000000 00000000 00000000 = 0
  ```

  如果对一个负数进行右移，最高位的`1`不动，结果仍为一个负数：

  ```java
  int n = -536870912;// 11100000 00000000 00000000 00000000 = -536870912
  int a = n >> 1;    // 11110000 00000000 00000000 00000000 = -268435456
  int b = n >> 2;    // 11111000 00000000 00000000 00000000 = -134217728
  int c = n >> 28;   // 11111111 11111111 11111111 11111110 = -2
  int d = n >> 29;   // 11111111 11111111 11111111 11111111 = -1
  ```

  还有一种不带符号的右移运算，`>>>`，特点是符号位跟着动，因此对一个负数进行`>>>`右移，它会变成正数，原因是最高位的`1`变成了`0`：

  ```java
  int n = -536870912;// 11100000 00000000 00000000 00000000 = -536870912
  int a = n >>> 1;   // 01110000 00000000 00000000 00000000 = -268435456
  int b = n >>> 2;   // 00111000 00000000 00000000 00000000 = 1879048192
  int c = n >>> 29;  // 00000000 00000000 00000000 00000111 = 7
  int d = n >>> 31;  // 00000000 00000000 00000000 00000001 = 1
  ```

  注意：

  * 对`byte`和`short`类型进行位移时，会首先转换成`int`再进行位移。这个转换是**自动类型转换（隐式）**，特点是代码不需要进行特殊处理，自动完成。规则是数据范围从小到大。
  * `byte` / `short` / `char`类型在进行运算时，会被首先提升为`int`再进行计算。

##### 位运算

* 位运算是按位进行与、或、非和异或的运算。

  * 与的规则，必须两个数字同时为`1`，结果才为`1`：

    ```java
    n = 0 & 0; // 0
    n = 0 & 1; // 0
    n = 1 & 0; // 0
    n = 1 & 1; // 1
    ```

  * 或的规则，只要任意一个数字为`1`，结果就为`1`：

    ```java
    n = 0 | 0; // 0
    n = 0 | 1; // 1
    n = 1 | 0; // 1
    n = 1 | 1; // 1
    ```

  * 非的规则，`0`和`1`互换：

    ```java
    n =  ~0; // 1
    n =  ~1; // 0
    ```

  * 异或的规则，如果两个数不同，结果为`1`，否则为`0`：

    ```java
    n = 0 ^ 0; // 0
    n = 0 ^ 1; // 1
    n = 1 ^ 0; // 1
    n = 1 ^ 1; // 0
    ```

  * 对两个整数进行位数运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：

    ```java
    //位运算
    public class Main{
        public static void main(String[] args){
            int i = 167776589; // 00001010 00000000 00010001 01001101
            int n = 167776512; // 00001010 00000000 00010001 00000000
            System.out.println(i & n); // 167776512
        }
    }
    ```

    上述按位与运算实际上可以看作两个整数表示的IP地址`10.0.17.77`和`10.0.17.0`，通过与运算，可以快速判断一个IP是否在给定的网段内。

##### 运算优先级

* 在Java的计算表达式中，运算优先级从高到低依次是：
  * `()`
  * `!` `~` `++` `--`
  * `*` `/` `%`
  * `+` `-`
  * `<<` `>>` `>>>`
  * `&`
  * `|`
  * `+=` `-=` `*=` `/=`

* 记不住可以通过加括号来保证优先级正确。

##### 类型自动提升与强制转型

* 类型自动提升

  * 在运算过程中，如果参与运算的两个数的类型不一致，那么计算结果为较大类型的整型。例如，`short`和`int`计算，结果总是`int`，原因是`short`首先自动被转型为`int`：

    ```java
    //类型自动提升与强制转型
    public class Main {
        public static void main(String[] args) {
            short s = 12;
            int i = 123;
            int x = s + i; // s自动转型为int
            short y = s + i; // 编译错误!
        }
    }
    
    ```

    

* 强制转型

  * 也可以将结果强制转型，将大范围的整数转型为小范围的整数。强制转型使用`(类型)`，例如，将`int`强制转型为`short`：

    ```java
    int i = 123;
    short s = (short) i;// 123
    ```

    注意：强制转型有可能会出现结果错误，原因是转型时，`int`的两个高位字节被丢弃，仅保留了低位的两个字节：

    ```java
    //强制转型
    public class Main {
        public static void main(String[] args) {
            int i1 = 1234567;
            short s1 = (short) i1; // -10617
            System.out.println(s1);
            int i2 = 12345678;
            short s2 = (short) i2; // 24910
            System.out.println(s2);
        }
    }
    
    ```

    因此，强制转型的结果很可能是错的。

